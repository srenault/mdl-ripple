const Constant = {
  INITIAL_SCALE: 'scale(0.0001, 0.0001)',
  INITIAL_SIZE: '1px',
  INITIAL_OPACITY: '0.4',
  FINAL_OPACITY: '0',
  FINAL_SCALE: '',
  INITIAL_BACKGROUND: 'grey',
  INITIAL_DURATION: '2s'
};

const CssClasses = {
  RIPPLE_READY: 'mdl-ripple--ready'
};

export default function init(element, options) {

  options = options ? options : {};

  options.background = options.background ? options.background : Constant.INITIAL_BACKGROUND;
  options.duration = options.duration ? options.duration : Constant.INITIAL_DURATION;

  let rippleElement;
  let frameCount = 0, rippleSize, x, y, boundHeight, boundWidth = 0;
  let recentering, ignoringMouseDown = false;

  if (element) {

    initElementStyles();
    rippleElement = document.createElement('span');
    initRippleStyles();
    element.appendChild(rippleElement);

    recentering = element.classList.contains(CssClasses.RIPPLE_CENTER);

    if(!options.ignoreEvents) {
      element.addEventListener('mousedown', boundDownHandler);
      element.addEventListener('mouseleave', boundUpHandler);
      element.addEventListener('touchstart', boundDownHandler);
      element.addEventListener('touchend', boundUpHandler);
      element.addEventListener('blur', boundUpHandler);
    }
  }

  function boundDownHandler(event) {
    if (!rippleElement.classList.contains(CssClasses.RIPPLE_READY)) {
      const rect = element.getBoundingClientRect();
      boundHeight = rect.height;
      boundWidth = rect.width;
      rippleSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2;
      rippleElement.style.width = rippleSize + 'px';
      rippleElement.style.height = rippleSize + 'px';
      rippleElement.classList.add(CssClasses.RIPPLE_READY);
    }

    rippleElement.style.opacity = 0.3;
    if (event.type === 'mousedown' && ignoringMouseDown) {
      ignoringMouseDown = false;
    } else {

      if (event.type === 'touchstart') ignoringMouseDown = true;
      if (frameCount > 0) return;
      frameCount = 1;

      const bound = event.target.getBoundingClientRect();

      // Check if we are handling a keyboard click.
      if (event.clientX === 0 && event.clientY === 0) {
        x = Math.round(bound.width / 2);
        y = Math.round(bound.height / 2);
      } else {
        const clientX = event.clientX ? event.clientX : event.touches[0].clientX;
        const clientY = event.clientY ? event.clientY : event.touches[0].clientY;
        x = Math.round(clientX - bound.left);
        y = Math.round(clientY - bound.top);
      }
      setRippleStyles(true);
      window.requestAnimationFrame(animFrameHandler.bind(this));
    }
  }

  function boundUpHandler(event) {
    // Don't fire for the artificial "mouseup" generated by a double-click.
    if (event && event.detail !== 2) {
      rippleElement.style.opacity = 0;
    }
    // Allow a repaint to occur before removing this class, so the animation
    // shows for tap events, which seem to trigger a mouseup too soon after
    // mousedown.
    window.setTimeout(function() {
      rippleElement.style.opacity = 0;
    }.bind(this), 0);
  }

  function initElementStyles() {
    element.style.position = 'relative';
    element.style.overflow = 'hidden';
  }

  function initRippleStyles() {
    rippleElement.style.background = options.background;
    rippleElement.style.borderRadius = '50%';
    rippleElement.style.height = '50px';
    rippleElement.style.left = '0';
    rippleElement.style.opacity = 0;
    rippleElement.style.pointerEvents = 'none';
    rippleElement.style.position = 'absolute';
    rippleElement.style.top = '0';
    rippleElement.style.transform = 'translate(-50%, -50%)';
    rippleElement.style.width = '50px';
    rippleElement.style.overflow = 'hidden';
  }

  function setRippleStyles(start) {
    if (rippleElement !== null) {
      let scale, size;
      let offset = 'translate(' + x + 'px, ' + y + 'px)';

      if (start) {
        scale = Constant.INITIAL_SCALE;
        size = Constant.INITIAL_SIZE;
      } else {
        scale = Constant.FINAL_SCALE;
        size = rippleSize + 'px';
        if (recentering) {
          offset = 'translate(' + boundWidth / 2 + 'px, ' + boundHeight / 2 + 'px)';
        }
      }

      const transformString = 'translate(-50%, -50%) ' + offset + scale;

      rippleElement.style.webkitTransform = transformString;
      rippleElement.style.msTransform = transformString;
      rippleElement.style.transform = transformString;

      if (start) {
        rippleElement.style.transition = '';
      } else {
        const transitionTransform = 'transform '+ options.duration +' cubic-bezier(0, 0, 0.2, 1)';
        const transitionWidth = 'width '+ options.duration +' cubic-bezier(0, 0, 0.2, 1)';
        const transitionHeight = 'height '+ options.duration +' cubic-bezier(0, 0, 0.2, 1)';
        const transitionOpacity = 'opacity 0.6s cubic-bezier(0, 0, 0.2, 1)';
        rippleElement.style.transition = [transitionTransform, transitionWidth, transitionHeight, transitionOpacity].join(', ');
      }
    }
  }

  function animFrameHandler() {
    if (frameCount-- > 0) {
      window.requestAnimationFrame(animFrameHandler.bind(this));
    } else {
      setRippleStyles(false);
    }
  }

  function downgrade() {
    element.removeEventListener('mousedown', boundDownHandler);
    element.removeEventListener('touchstart', boundDownHandler);
    element.removeEventListener('mouseup', boundUpHandler);
    element.removeEventListener('mouseleave', boundUpHandler);
    element.removeEventListener('touchend', boundUpHandler);
    element.removeEventListener('blur', boundUpHandler);
  }

  return {
    downgrade: downgrade,

    trigger: function(e) {
      downgrade();
      element.addEventListener('mouseleave', boundUpHandler);
      element.addEventListener('touchend', boundUpHandler);
      element.addEventListener('blur', boundUpHandler);
      boundDownHandler(e);
    }
  };
}
