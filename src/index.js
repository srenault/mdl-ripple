const Constant = {
  INITIAL_SCALE: 'scale(0.0001, 0.0001)',
  INITIAL_SIZE: '1px',
  INITIAL_OPACITY: '0.4',
  FINAL_OPACITY: '0',
  FINAL_SCALE: ''
};

const CssClasses = {
  RIPPLE_ROOT: 'ripple',
  RIPPLE_CONTAINER: 'mdl-list__item__ripple-container',
  RIPPLE_CENTER: 'mdl-ripple--center',
  RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
  RIPPLE: 'mdl-ripple',
  IS_ANIMATING: 'is-animating',
  IS_VISIBLE: 'is-visible'
};

export default function init(element) {

  let rippleElement;
  let frameCount = 0, rippleSize, x, y, boundHeight, boundWidth = 0;
  let recentering, ignoringMouseDown = false;

  if (element) {

    if (!element.classList.contains(CssClasses.RIPPLE_ROOT)) {
      const rippleContainer = document.createElement('span');
      rippleContainer.classList.add(CssClasses.RIPPLE_CONTAINER);
      rippleElement = document.createElement('span');
      rippleElement.classList.add(CssClasses.RIPPLE);
      rippleContainer.appendChild(rippleElement);
      element.appendChild(rippleContainer);
      element.classList.add(CssClasses.RIPPLE_ROOT);
    }

    recentering = element.classList.contains(CssClasses.RIPPLE_CENTER);

    if (!element.classList.contains(CssClasses.RIPPLE_EFFECT_IGNORE_EVENTS)) {

      rippleElement = element.querySelector('.' + CssClasses.RIPPLE);

      element.addEventListener('mousedown', boundDownHandler);
      element.addEventListener('mouseleave', boundUpHandler);
      element.addEventListener('touchstart', boundDownHandler);
      element.addEventListener('touchend', boundUpHandler);
      element.addEventListener('blur', boundUpHandler);
    }
  }

  function boundDownHandler(event) {
    if (!rippleElement.style.width && !rippleElement.style.height) {
      const rect = element.getBoundingClientRect();
      boundHeight = rect.height;
      boundWidth = rect.width;
      rippleSize = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2;
      rippleElement.style.width = rippleSize + 'px';
      rippleElement.style.height = rippleSize + 'px';
    }

    rippleElement.classList.add(CssClasses.IS_VISIBLE);

    if (event.type === 'mousedown' && ignoringMouseDown) {
      ignoringMouseDown = false;
    } else {

      if (event.type === 'touchstart') ignoringMouseDown = true;
      if (frameCount > 0) return;
      frameCount = 1;

      const bound = event.currentTarget.getBoundingClientRect();

      // Check if we are handling a keyboard click.
      if (event.clientX === 0 && event.clientY === 0) {
        x = Math.round(bound.width / 2);
        y = Math.round(bound.height / 2);
      } else {
        const clientX = event.clientX ? event.clientX : event.touches[0].clientX;
        const clientY = event.clientY ? event.clientY : event.touches[0].clientY;
        x = Math.round(clientX - bound.left);
        y = Math.round(clientY - bound.top);
      }
      setRippleStyles(true);
      window.requestAnimationFrame(animFrameHandler.bind(this));
    }
  }

  function boundUpHandler(event) {
    // Don't fire for the artificial "mouseup" generated by a double-click.
    if (event && event.detail !== 2) {
      rippleElement.classList.remove(CssClasses.IS_VISIBLE);
    }
    // Allow a repaint to occur before removing this class, so the animation
    // shows for tap events, which seem to trigger a mouseup too soon after
    // mousedown.
    window.setTimeout(function() {
      rippleElement.classList.remove(CssClasses.IS_VISIBLE);
    }.bind(this), 0);
  }

  function setRippleStyles(start) {
    if (rippleElement !== null) {
      let scale, size;
      let offset = 'translate(' + x + 'px, ' + y + 'px)';

      if (start) {
        scale = Constant.INITIAL_SCALE;
        size = Constant.INITIAL_SIZE;
      } else {
        scale = Constant.FINAL_SCALE;
        size = rippleSize + 'px';
        if (recentering) {
          offset = 'translate(' + boundWidth / 2 + 'px, ' + boundHeight / 2 + 'px)';
        }
      }

      const transformString = 'translate(-50%, -50%) ' + offset + scale;

      rippleElement.style.webkitTransform = transformString;
      rippleElement.style.msTransform = transformString;
      rippleElement.style.transform = transformString;

      if (start) {
        rippleElement.classList.remove(CssClasses.IS_ANIMATING);
      } else {
        rippleElement.classList.add(CssClasses.IS_ANIMATING);
      }
    }
  }

  function animFrameHandler() {
    if (frameCount-- > 0) {
      window.requestAnimationFrame(animFrameHandler.bind(this));
    } else {
      setRippleStyles(false);
    }
  }

  return {
    downgrade: function() {
      element.removeEventListener('mousedown', boundDownHandler);
      element.removeEventListener('touchstart', boundDownHandler);
      element.removeEventListener('mouseup', boundUpHandler);
      element.removeEventListener('mouseleave', boundUpHandler);
      element.removeEventListener('touchend', boundUpHandler);
      element.removeEventListener('blur', boundUpHandler);
    }
  };
}
